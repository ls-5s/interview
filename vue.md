一边http,一边vue,一边复习js,css
# 11.10
## 面试官：v-show和v-if有什么区别？使用场景分别是什么？
**差别**
- 渲染机制不一样
**v-show**:是条件显示：无论条件为 true 还是 false，元素始终会被渲染到 DOM 中，只是通过 CSS 的 display 属性控制显示（display: block）或隐藏（display: none）。
**v-if**：是条件渲染：当条件为 false 时，元素不会被渲染到 DOM 中（相当于从 DOM 树中移除）；只有条件为 true 时，才会创建元素并插入 DOM。

- 性能开销不同
**v-if**：有更高的切换开销：每次条件变化时，会触发元素的创建 / 销毁（包括内部子组件的生命周期、事件监听器的绑定 / 解绑），适合条件不频繁切换的场景。
**v-show**：有更高的初始渲染开销：因为无论条件如何，元素都会被渲染，但其切换开销极低（仅修改 CSS），适合条件需要频繁切换的场景。

- 语法限制不同
**v-if**： 可以和 v-else、v-else-if 搭配使用，形成条件分支逻辑（需相邻摆放，否则失效）。
**v-show** 不支持 v-else，只能单独使用。

- 批量渲染
v-if 可以直接作用于标签（用于 “分组条件渲染”，避免额外 DOM 节点），比如：
```vue
<template v-if="flag">
  <div>内容1</div>
  <div>内容2</div>
</template>
```
但 v-show不能作用于（因为本身不会被渲染为真实 DOM，而 v-show 依赖修改 DOM 的display属性）。

**使用场景**
**v-if**：当条件很少变化
- 如权限控制：未登录用户看不到 “个人中心” 按钮

**v-show**:频繁切换显示 / 隐藏
- 如 tabs 标签切换、弹窗的显示 / 隐藏

## 面试官：SPA首屏加载速度慢的怎么解决？
- 什么是首屏加载
首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

- 加载慢的原因

================================================

网络延时问题
资源文件体积是否过大
资源是否重复发送请求去加载了
加载脚本的时候，渲染内容堵塞了
 
===============================================

- 解决方案

===============================================

- 减小入口文件体积(采用动态加载路由的形式)
常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加
```vue
routes:[ 
    path: 'Blogs',
    name: 'ShowBlogs',
    component: () => import('./components/ShowBlogs.vue')
]
以函数的形式加载
```
以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件

- 使用SSR
SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器
从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染

- 图片资源的压缩
图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素
对于所有的图片资源，我们可以进行适当的压缩
对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。

- 组件重复打包

假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载
解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置
```js
minChunks: 3
```
minChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

- UI框架按需加载
- 开启GZip压缩



==============================================
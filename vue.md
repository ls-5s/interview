一边http,一边vue,一边复习js,css
# 11.10
## 面试官：v-show和v-if有什么区别？使用场景分别是什么？
**差别**
- 渲染机制不一样
**v-show**:是条件显示：无论条件为 true 还是 false，元素始终会被渲染到 DOM 中，只是通过 CSS 的 display 属性控制显示（display: block）或隐藏（display: none）。
**v-if**：是条件渲染：当条件为 false 时，元素不会被渲染到 DOM 中（相当于从 DOM 树中移除）；只有条件为 true 时，才会创建元素并插入 DOM。

- 性能开销不同
**v-if**：有更高的切换开销：每次条件变化时，会触发元素的创建 / 销毁（包括内部子组件的生命周期、事件监听器的绑定 / 解绑），适合条件不频繁切换的场景。
**v-show**：有更高的初始渲染开销：因为无论条件如何，元素都会被渲染，但其切换开销极低（仅修改 CSS），适合条件需要频繁切换的场景。

- 语法限制不同
**v-if**： 可以和 v-else、v-else-if 搭配使用，形成条件分支逻辑（需相邻摆放，否则失效）。
**v-show** 不支持 v-else，只能单独使用。

- 批量渲染
v-if 可以直接作用于标签（用于 “分组条件渲染”，避免额外 DOM 节点），比如：
```vue
<template v-if="flag">
  <div>内容1</div>
  <div>内容2</div>
</template>
```
但 v-show不能作用于（因为本身不会被渲染为真实 DOM，而 v-show 依赖修改 DOM 的display属性）。

**使用场景**
**v-if**：当条件很少变化
- 如权限控制：未登录用户看不到 “个人中心” 按钮

**v-show**:频繁切换显示 / 隐藏
- 如 tabs 标签切换、弹窗的显示 / 隐藏

## 面试官：SPA首屏加载速度慢的怎么解决？
- 什么是首屏加载
首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

- 加载慢的原因

================================================

网络延时问题
资源文件体积是否过大
资源是否重复发送请求去加载了
加载脚本的时候，渲染内容堵塞了
 
===============================================

- 解决方案

===============================================

- 减小入口文件体积(采用动态加载路由的形式)
常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加
```vue
routes:[ 
    path: 'Blogs',
    name: 'ShowBlogs',
    component: () => import('./components/ShowBlogs.vue')
]
以函数的形式加载
```
以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件

- 使用SSR
SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器
从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染

- 图片资源的压缩
图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素
对于所有的图片资源，我们可以进行适当的压缩
对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。

- 组件重复打包

假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载
解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置
```js
minChunks: 3
```
minChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

- UI框架按需加载
- 开启GZip压缩



==============================================

## 如果前端要接受很多图片资源，你该如何让优化？

## 面试官：说说你对keep-alive的理解是什么？
定义：keep-alive它是一个内置组件，作用:缓存包裹的组件实例，避免组件在切换时被频繁创建和注销，提高页面的性能并保留组件状态

=================================================

**核心作用**
- 缓存组件实例: 被keep-alive 包裹的组件，在第一次渲染后被缓存到内存中，后续切换时不会重新执行初始化（如created、mounted等钩子），而是直接复用缓存的实例。
- 保留组件状态：例如表单输入内容、列表滚动位置等状态，在组件切换后不会丢失。
- 优化性能： 减少DOM 操作和组件初始化开销，尤其适合频繁切换的场景（如标签页、路由切换）
  
**使用场景**
- 列表页 → 详情页：返回列表页时保持之前的滚动位置和筛选状态。
- 多标签页切换：缓存每个标签页的内容，避免重复加载。
- 表单页面：切换到其他页面后返回，保留已输入的表单数据。

**实现原理**
keep-alive 本质是一个抽象的组件(不会渲染DOM元素)
1. 组件首次渲染时，将组件实例存入内部缓存对象,并记录键名
2. 当组件再次渲染，直接从缓存中读取实例，跳过初始化过程
3. 当组件被影藏(如切换到其他组件)，会被标记为缓存状态
**核心属性**
- include：指定需要缓存的组件（值为字符串、正则、数组，匹配组件name）。
- exclude：指定不需要缓存的组件（规则同include，优先级高于include）。
- max：限制缓存的组件实例数量（类型为 Number），超出时会删除 “最久未使用” 的实例（LRU 策略）。

**注意事项**
仅对动态组件（<component :is="xxx">）或路由组件（配合<router-view>）有效。
缓存的组件若依赖外部数据变化，需在activated中手动更新（避免显示旧数据）。
若组件内有定时器、事件监听等，需在deactivated中清除（避免内存泄漏）。
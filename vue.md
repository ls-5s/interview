一边http,一边vue,一边复习js,css
# 11.10
## 面试官：v-show和v-if有什么区别？使用场景分别是什么？
**差别**
- 渲染机制不一样
**v-show**:是条件显示：无论条件为 true 还是 false，元素始终会被渲染到 DOM 中，只是通过 CSS 的 display 属性控制显示（display: block）或隐藏（display: none）。
**v-if**：是条件渲染：当条件为 false 时，元素不会被渲染到 DOM 中（相当于从 DOM 树中移除）；只有条件为 true 时，才会创建元素并插入 DOM。

- 性能开销不同
**v-if**：有更高的切换开销：每次条件变化时，会触发元素的创建 / 销毁（包括内部子组件的生命周期、事件监听器的绑定 / 解绑），适合条件不频繁切换的场景。
**v-show**：有更高的初始渲染开销：因为无论条件如何，元素都会被渲染，但其切换开销极低（仅修改 CSS），适合条件需要频繁切换的场景。

- 语法限制不同
**v-if**： 可以和 v-else、v-else-if 搭配使用，形成条件分支逻辑（需相邻摆放，否则失效）。
**v-show** 不支持 v-else，只能单独使用。

- 批量渲染
v-if 可以直接作用于标签（用于 “分组条件渲染”，避免额外 DOM 节点），比如：
```vue
<template v-if="flag">
  <div>内容1</div>
  <div>内容2</div>
</template>
```
但 v-show不能作用于（因为本身不会被渲染为真实 DOM，而 v-show 依赖修改 DOM 的display属性）。

**使用场景**
**v-if**：当条件很少变化
- 如权限控制：未登录用户看不到 “个人中心” 按钮

**v-show**:频繁切换显示 / 隐藏
- 如 tabs 标签切换、弹窗的显示 / 隐藏

## 面试官：SPA首屏加载速度慢的怎么解决？
- 什么是首屏加载
首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

- 加载慢的原因

================================================

网络延时问题
资源文件体积是否过大
资源是否重复发送请求去加载了
加载脚本的时候，渲染内容堵塞了
 
===============================================

- 解决方案

===============================================

- 减小入口文件体积(采用动态加载路由的形式)
常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加
```vue
routes:[ 
    path: 'Blogs',
    name: 'ShowBlogs',
    component: () => import('./components/ShowBlogs.vue')
]
以函数的形式加载
```
以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件

- 使用SSR
SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器
从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染

- 图片资源的压缩
图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素
对于所有的图片资源，我们可以进行适当的压缩
对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。

- 组件重复打包

假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载
解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置
```js
minChunks: 3
```
minChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

- UI框架按需加载
- 开启GZip压缩



==============================================

## 如果前端要接受很多图片资源，你该如何让优化？

## 面试官：说说你对keep-alive的理解是什么？
定义：keep-alive它是一个内置组件，作用:缓存包裹的组件实例，避免组件在切换时被频繁创建和注销，提高页面的性能并保留组件状态

=================================================

**核心作用**
- 缓存组件实例: 被keep-alive 包裹的组件，在第一次渲染后被缓存到内存中，后续切换时不会重新执行初始化（如created、mounted等钩子），而是直接复用缓存的实例。
- 保留组件状态：例如表单输入内容、列表滚动位置等状态，在组件切换后不会丢失。
- 优化性能： 减少DOM 操作和组件初始化开销，尤其适合频繁切换的场景（如标签页、路由切换）
  
**使用场景**
- 列表页 → 详情页：返回列表页时保持之前的滚动位置和筛选状态。
- 多标签页切换：缓存每个标签页的内容，避免重复加载。
- 表单页面：切换到其他页面后返回，保留已输入的表单数据。

**实现原理**
keep-alive 本质是一个抽象的组件(不会渲染DOM元素)
1. 组件首次渲染时，将组件实例存入内部缓存对象,并记录键名
2. 当组件再次渲染，直接从缓存中读取实例，跳过初始化过程
3. 当组件被影藏(如切换到其他组件)，会被标记为缓存状态
**核心属性**
- include：指定需要缓存的组件（值为字符串、正则、数组，匹配组件name）。
- exclude：指定不需要缓存的组件（规则同include，优先级高于include）。
- max：限制缓存的组件实例数量（类型为 Number），超出时会删除 “最久未使用” 的实例（LRU 策略）。

**注意事项**
仅对动态组件（<component :is="xxx">）或路由组件（配合<router-view>）有效。
缓存的组件若依赖外部数据变化，需在activated中手动更新（避免显示旧数据）。
若组件内有定时器、事件监听等，需在deactivated中清除（避免内存泄漏）。

## 面试官：你知道vue中key的原理吗？说说你对它的理解 ?
帮助 Vue 的虚拟 DOM Diff 算法更高效、更准确地识别节点的变化
**核心原理：**
Vue在跟新DOM 时，会通过虚拟DOM diff 对比新老虚拟节点树的差异，在映射到真的DOM上
key的作用是让Vue 能快速判断两个节点是否是同一个节点。
- 如果两个节点的key不同，Vue 会判断他们不是同一个节点，会销毁老的节点创建新的节点
- 如果key是一样的，而且标签名也相同，Vue会认为他们是同一个节点，进度只跟新节点的内容，
避免重新创造DOM 元素
**为什么需要key?**
我这边就直接举一个例子吧
有一个列表[A,B,C],渲染为三个输入框，用户A的输入框输入了内容，如果删除A,列表变成了[B,C]
- 没有key时，Vue 会复用原来的第一个节点(A的位置来渲染B),第二个节点（B 的位置）渲染 C。这会导致 A 输入框的内容被错误地 “继承” 到 B 的输入框中（因为节点被就地复用了）。
- 有key的话，假如A，B,C 的key 分别为1，2，3 ，Vue 会识别到key=1的节点被删除，key=2和key=3的节点需要保留并移动位置，输入框的状态会正确保留。
**key的正确使用方式**
- 用唯一且稳定的标识作为Key：通常是后端返回的id
- 避免使用index作为key:如果列表发生排序，删除等问题，index会发生改成(比如删除第一个元素，后面元素的index都会减 1),导致key失效。此时 Vue 会认为节点被替换，反而会增加 DOM 操作，降低性能，甚至重现 “就地复用” 的问题。
# 11.11
## 面试官：什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路
**什么是虚拟的DOM?**
- 本质：它是一个真实DOM 节点 的js 对象，包含节点的标签名，属性，子节点，key等核心信息。
- 作用：作为数据和真实DOM 之间是中间层，避免直接频繁操作真实DOM(真实 DOM 操作耗时且耗性能)。
- 核心流程： 数据更新 → 生成新虚拟 DOM → 与旧虚拟 DOM 对比（diff）→ 只把差异同步到真实 DOM。
**如何实现一个虚拟DOM**
- 定义VNode 结构(虚拟节点的数据模型)
tag：节点标签名（如 div、span）。
props：节点属性（如 class、style、onClick）。
children：子节点数组（可能是 VNode 或文本节点）。
key：节点唯一标识（用于 diff 算法）。
text：文本节点内容（若为文本节点）。
el：对应的真实 DOM 元素（用于后续挂载 / 更新）。
- 实现render 函数(VNode -> 真实DOM)
将 VNode 对象转换为真实 DOM 元素，挂载到页面上：
若为文本节点：直接创建文本 DOM（document.createTextNode）。
若为元素节点：创建对应标签的 DOM（document.createElement），递归处理子节点并挂载。
- 实现 diff 算法（对比新旧 VNode，找差异）
- 实现 patch 函数（应用差异到真实 DOM）
根据 diff 算法找到的差异，修改真实 DOM：

## 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢
**定义**：SPA,他是前端应用的架构模式，核心特点是整个应用页面只加载一个主的HTML 页面，后面内容的切换
数据的跟新通过JavaScript 动态渲染DOM 完成，无需重新请求和加载HTML页面。
**对于spa的核心理解**
- 核心逻辑："前端路由 + 动态试图渲染"
- 初始加载时，浏览器请求并加载唯一的主页面（如index.html），同时加载应用所需的 JavaScript、CSS 等资源；
- 当用户页面跳转，前端路由拦截URL变化，不向服务器发送新的页面请求。
- 前端框架（如 Vue、React）根据路由规则，动态渲染对应的组件 / 视图，并通过 AJAX/HTTP 请求获取数据，更新页面内容；
- 整个过程中，页面不会刷新，URL 的变化仅通过前端逻辑管理（如 hash 值变化或 HTML5 History API）。

**SPA 的优点**
1.用户体验更流畅
避免了传统多页面应用中 “跳转 - 白屏 - 加载” 的过程，视图切换瞬间完成，减少用户等待感，接近原生 App 的体验。
2.前后端分离彻底
后端仅需提供 API 接口（负责数据处理），前端专注于视图渲染和交互逻辑，职责清晰，便于团队分工（前端、后端可并行开发）
3.减少服务器压力
4.缓存友好
静态资源（JS、CSS、图片）可被浏览器缓存，再次访问时无需重新加载，提升加载速度。

**SPA 的缺点**
1. 首页加载速度可能较慢
初始加载需一次性下载整个应用的核心 JS/CSS 资源（尤其是大型应用），若资源体积大，可能导致首屏白屏时间过长。
2. SEO（搜索引擎优化）不友好
3. 前进 / 后退功能需要手动处理
4. 内存占用较高

**如何实现一个 SPA 应用?**

# 11.12
## 面试官：Vue组件之间的通信方式都有哪些？
1. 父子组件通信
- 父传子(props)
父组件通过v-bind像子组件传递数据
```js
<template>
  <!-- 父组件向子组件传递数据，仍使用 v-bind（或简写 `:`） -->
  <Child :message="parentMsg" />
</template>

<script setup>
import { ref } from 'vue'
const parentMsg = ref('这是父组件传递的消息')
</script>
```
```js
<script setup>
import { defineProps } from 'vue'

// 声明接收的 props（支持指定类型、默认值等）
const props = defineProps({
  message: {
    type: String, // 指定类型
    required: true // 可选：标记为必填
  }
})

// 直接访问 props 中的数据
console.log(props.message)
</script>
```
- 子传父emit触发自定义事件，父组件通过v-on 监听事件并接收数据。
```js
<template>
  <button @click="handleClick">发送数据</button>
</template>

<script setup>
// 引入 defineEmits 定义可触发的事件
const emit = defineEmits(['send-data']);

const handleClick = () => {
  emit('send-data', '子组件的数据'); // 触发事件并传递参数
};
</script>
<template>
  <Child @send-data="receiveData" />
</template>

<script setup>
import Child from './Child.vue'; // 引入子组件

const receiveData = (data) => {
  console.log(data); // 输出：子组件的数据
};
</script>
```
- ref 一般是子传父
Vue3 中为了增强组件封装性，默认不暴露组件内部的方法 / 数据，需通过 defineExpose 显式暴露才能被父组件访问。
```js
子
<script setup>
import { ref } from 'vue';

// 子组件内部数据
const childData = ref('子组件的私有数据');

// 子组件内部方法
const childMethod = () => {
  console.log('子组件的方法被调用了！');
};

// 🔴 关键：显式暴露给父组件访问的内容
defineExpose({
  childData,
  childMethod
});
</script>

父组件（通过 ref 访问子组件实例）<template>
  <div>
    <!-- 子组件 -->
    <Child ref="childRef" />
    <!-- 按钮触发函数 -->
    <button @click="callChildMethod">调用子组件方法</button>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import Child from './Child.vue';

// 绑定子组件实例的ref
const childRef = ref(null);

// 封装调用子组件逻辑的函数
const callChildMethod = () => {
  // 安全校验：确保子组件实例已挂载（避免null报错）
  if (childRef.value) {
    // 调用子组件暴露的方法
    childRef.value.childMethod();
    // 访问子组件暴露的数据
    console.log('子组件数据：', childRef.value.childData);
  } else {
    console.log('子组件尚未挂载');
  }
};
</script>

```
- 祖孙与后代组件之间的通信
结合ref/reactive实现响应式，顶层组件用provide函数，后代用inject函数。
```vue
<!-- 祖父组件 -->
<script setup>
import { ref, provide } from 'vue';
const theme = ref('light'); // 响应式数据
// 提供响应式数据和修改方法
provide('theme', theme);
provide('setTheme', (newTheme) => { theme.value = newTheme; });
</script>

<!-- 孙子组件 -->
<script setup>
import { inject } from 'vue';
const theme = inject('theme'); // 直接注入响应式数据
const setTheme = inject('setTheme'); // 注入方法

console.log(theme.value); // 'light'
</script>
```
- 非关系组件间之间的通信(pinia)
- 兄弟组件之间的通信(EventBus)
创建一个中央事件总线EventBus
兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值
另一个兄弟组件通过$on监听自定义事件

## 面试官：为什么data属性是一个函数而不是一个对象？
组件的data必须是一个函数而不是对象,是为了保证组件的复用性和独立性
**具体原因避免数据共享导致的副作用**
- Vue 组件是可复用的实例。如果data是一个对象，那么所有复用该组件的实例会共享同一个 data 对象的引用。这意味着当其中一个组件实例修改 data 中的数据时，其他所有实例的 data 会被同步修改（因为它们指向同一块内存），这显然不符合组件 “独立复用” 的设计初衷。
- 而如果data是一个函数，每次创建组件实例时，函数都会被调用并返回一个全新的对象（每个实例都拥有自己独立的 data 副本）。这样一来，多个组件实例之间的 data 互不干扰，各自的状态修改只会影响自身，保证了组件的独立性。

## 面试官：说说对WebSocket的理解？应用场景？
**对WebSocket的核心理解**
1. 与http的区别(核心优势)
- 效率：HTTP 每次通信需重新建立连接（包含三次握手等开销），且头部信息冗余；WebSocket 仅在握手阶段使用 HTTP 协议，之后直接通过 TCP 传输数据，头部开销极小，实时性更高。
- 通信方式：HTTP 是 “请求 - 响应” 模式的单向通信（客户端主动请求，服务器被动响应），且每次通信后连接关闭；WebSocket 建立连接后，客户端和服务器可双向主动发送数据，连接长期保持。
2. 关键特点
- 全双工：客户端和服务器可同时向对方发送数据，无需等待对方响应。
- 持久连接：一旦握手成功，连接会持续保持，直到某一方主动关闭。
- 无同源限制：客户端可与任意服务器建立 WebSocket 连接（不同于 AJAX 的同源策略限制）。
- 协议标识：使用 ws://（非加密）或 wss://（加密，类似 HTTPS）作为协议前缀。
3. 工作流程(握手阶段)
- 客户端发起连接请求：通过 HTTP 协议发送握手请求，请求头包含特殊字段：
Upgrade: websocket（声明要升级为 WebSocket 协议）
Connection: Upgrade（确认升级连接）
Sec-WebSocket-Key（随机字符串，用于服务器验证）
Sec-WebSocket-Version（协议版本）。
- 服务器响应握手：服务器验证请求后，返回 HTTP 101 状态码（Switching Protocols），并通过 Sec-WebSocket-Accept 字段返回加密后的 Sec-WebSocket-Key 结果，确认协议切换。
- 双向通信：握手成功后，HTTP 连接升级为 WebSocket 连接，双方通过 TCP 直接交换数据（数据帧格式遵循 WebSocket 协议）。

**应用场景**
WebSocket最适合延迟底，高频次双向数据交换，传统 HTTP 轮询（定时请求）或长轮询（阻塞等待响应）在此类场景中效率极低（频繁建立连接、服务器压力大），而 WebSocket 能显著优化性能。
- 实时聊天 / 社交应用：如即时通讯工具（微信网页版）、弹幕系统、在线客服，需要双方实时收发消息。实时聊天 / 社交应用：如即时通讯工具（微信网页版）、弹幕系统、在线客服，需要双方实时收发消息。
- 实时数据监控：如股票行情、期货价格、实时交通流量（需服务器主动推送最新数据给客户端）。
- 在线协作工具：如多人编辑文档（Google Docs）、协同绘图，用户操作需实时同步给其他参与者。
- 实时游戏：尤其是多人在线游戏（如实时对战），玩家操作和游戏状态需毫秒级同步。

## 面试官：为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？
**Http 是超本文传输协议，其中是明文传输，有三个巨大的问题**
- 窃听风险：数据在传输途中，可能被第三方拦截并读取
- 篡改风险：第三方可能篡改传输的数据(比如订单金额)
- 冒充风险: 第三方可能冒充服务器或客户端（比如 “钓鱼网站” 冒充银行网站骗取用户信息）。
而 HTTPS（HTTP + SSL/TLS）通过 SSL/TLS 协议对数据进行加密处理，并加入身份验证和完整性校验机制，从根本上解决了这三大风险，因此更安全。
**二、HTTPS 如何保证安全？（核心机制）**
1. 数据加密：防止窃听
HTTPS 采用 “非对称加密 + 对称加密” 结合的方式加密数据，兼顾安全性和传输效率：
- 对称加密：客户端和服务器使用同一把密钥对数据进行加密和解密（比如 AES 算法）。优点是加密效率极高，适合大量数据传输；缺点是 “密钥如何安全传给对方”—— 如果直接传输密钥，可能被窃听。
- 非对称加密：使用 “公钥 - 私钥” 对（比如 RSA 算法）。公钥可公开，私钥仅服务器持有；用公钥加密的数据，只能用私钥解密，反之亦然。优点是无需担心密钥传输安全；缺点是加密效率低，不适合大量数据传输。
2. 数据完整性校验：防止篡改
HTTPS 通过 “消息认证码（MAC）” 或 “哈希算法（如 SHA）” 确保数据在传输中未被篡改：
- 发送方在传输数据时，会对数据进行哈希计算，生成一个 “哈希值”（相当于数据的 “指纹”），并将哈希值加密后和数据一起发送。
- 接收方收到数据后，对数据重新计算哈希值，与解密后的 “指纹” 对比：如果一致，说明数据未被篡改；如果不一致，则判定数据被篡改，拒绝接收。
3. 身份认证：防止冒充
HTTPS 通过 “数字证书 + CA 机构” 验证服务器身份，防止 “中间人冒充服务器”：
- 服务器的公钥需要向权威 CA 机构（如 Let's Encrypt、Verisign）申请 “数字证书”。证书中包含：服务器的公钥、服务器域名、证书有效期、CA 机构的签名（用 CA 私钥加密的证书信息哈希值）。
- 客户端连接服务器时，服务器会先发送数字证书。客户端会：
- 验证证书是否由可信 CA 机构颁发（操作系统 / 浏览器内置了可信 CA 的公钥）。
1. 用 CA 公钥解密证书中的 “CA 签名”，得到证书信息的哈希值，再与自己计算的证书信息哈希值对比，确认证书未被篡改。
2. 验证证书中的域名是否与当前访问的域名一致（防止 “钓鱼网站” 用其他域名的证书冒充）。
- 只有证书验证通过，客户端才会认为对方是 “真实的服务器”，继续后续通信；否则会提示 “证书不安全”（如浏览器显示警告页面）。
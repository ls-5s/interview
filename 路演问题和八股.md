## 用户登录模块
### 一、功能流程与核心逻辑
请描述一下你们项目中登录和注册的完整流程？需结合项目实现说明：
- 注册流程：前端通过表单收集用户名 / 密码，经本地验证（长度、非空）后调用register接口；后端接收数据后，先检查用户是否已存在（通过userRepository.findOne查询），若不存在则用bcrypt加密密码，生成uuid作为用户唯一标识，存储到数据库并返回JWT token；前端接收成功后切换到登录页。
- 登录流程：前端表单验证通过后调用login接口；后端查询用户存在性，通过bcrypt.compare验证密码，验证成功则生成JWT token（包含用户名信息），返回token、用户id和用户名；前端将token存入全局状态（userStore）和本地存储，跳转至漫画广场。
- 注册时如何保证用户名唯一？登录时如何验证用户身份？
用户名唯一：注册时后端通过userRepository.findOne({ where: { username } })查询数据库，若存在则返回409状态码（“账号存在”），阻止重复注册。
身份验证：登录时后端先查询用户是否存在，再通过bcrypt.compare比对输入密码与数据库中存储的哈希密码，验证通过后生成token确认身份。
### 二、安全性设计
- 密码存储为什么不用明文？你们用了什么加密方式？有什么优势？
明文存储风险：密码泄露后直接暴露用户信息，存在极大安全隐患。
项目实现：使用bcrypt进行哈希加密（bcrypt.hash(password, saltRounds)），优势在于：
自带 “加盐”（salt）机制，相同密码会生成不同哈希值，防止彩虹表攻击；
计算耗时较长（可通过saltRounds调整），能抵御暴力破解。
- 为什么用 JWT 存储登录状态？相比 Session 有什么优势？
项目实现：登录成功后生成JWT token（jwt.sign），包含用户信息和过期时间，前端存储token用于后续接口认证。
优势：
无状态：后端无需存储会话信息，减轻服务器压力，适合分布式系统；
自包含：token携带用户身份信息，减少数据库查询；
跨域支持：便于前后端分离或多端（Web/APP）统一认证。
- 如何防止 SQL 注入和 XSS 攻击？
SQL 注入防护：后端使用TypeORM的Repository接口（如findOne、save），通过参数化查询自动处理输入，避免直接拼接 SQL 语句。
XSS 防护：前端通过Element Plus表单组件进行输入验证（如长度限制、非空检查），后端接口也会验证参数合法性（如uuid非空校验），减少恶意脚本注入风险。
- token 存储在 localStorage 有什么风险？如何优化？
风险：localStorage属于本地存储，易被 XSS 攻击窃取（脚本可直接读取）。
项目现状：当前用localStorage持久化token，避免页面刷新丢失。
优化方向：可改用httpOnly cookie 存储token，禁止前端脚本访问，降低 XSS 风险；同时配合SameSite属性防止 CSRF 攻击。
### 三、技术细节与实现
- 前端表单验证做了哪些处理？如何提升用户体验？
验证规则：通过formRules定义用户名（3-20 字符）、密码（6-20 字符）的长度限制，非空校验，触发时机为blur（失焦），实时反馈错误。
体验优化：
按钮加载状态（loginLoading、registerLoading），避免重复提交；
错误提示使用ElMessage，居中显示并设置偏移量，样式与全局风格统一；
注册成功后自动切换到登录页，减少用户操作成本。
- 后端如何处理 token 的过期与验证？
过期设置：生成token时通过expiresIn（环境变量JWT_EXPIRES_IN）指定有效期，避免永久有效。
验证流程：后端接口（如漫画查询、模板管理）通过中间件检查请求头中的Authorization字段，解析token并验证签名和有效期，无效则返回错误。
用户登录状态如何在前端路由中生效？未登录用户访问受限页面会怎样？
状态管理：通过userStore存储token和用户名，路由切换时通过activeIndex计算属性判断当前路径。
权限控制：如 “漫画创作”“个人中心” 等页面，在handleMenuSelect中检查userStore.token，若未登录可提示用户先登录（项目中通过ElMessage反馈）。
### 四、异常处理与边界情况
- 注册 / 登录失败时有哪些异常情况？如何处理？
注册失败：用户名已存在（返回409）、服务器错误（500），前端提示 “注册失败，请重试” 并打印错误日志。
登录失败：用户名不存在或密码错误（返回401）、服务器错误（500），前端提示 “登录失败，请检查用户名和密码”。
通用处理：通过try/catch捕获接口异常，保证页面不崩溃，同时提供明确的错误提示。
- 页面刷新后登录状态会丢失吗？为什么？
不会丢失。项目中登录成功后，token不仅存入全局状态（userStore），还通过localStorage持久化存储（前端状态管理库如 Pinia 在刷新后会重置，需从localStorage恢复），因此刷新后可重新读取token恢复登录状态。
五、扩展性与优化
- 如何实现 “记住密码” 功能？
可在登录表单添加 “记住密码” 复选框，若勾选则将用户名 / 密码（加密后）存入localStorage，下次打开页面时自动填充表单；但需注意密码加密存储（如用CryptoJS），降低泄露风险。
如果要添加第三方登录（如微信、GitHub），需要做哪些改动？
前端：添加第三方登录按钮，对接对应平台的 OAuth 授权页面，获取授权码。
后端：新增第三方登录接口，通过授权码调用平台 API 获取用户信息，关联本地用户（新建或绑定已有账号），生成并返回JWT token。
- 如何优化高频登录场景的性能？
前端：对登录按钮添加防抖（避免快速点击），表单验证前置（减少无效接口请求）。
后端：缓存高频登录用户的信息（如 Redis），减少数据库查询；优化bcrypt加密耗时（平衡安全性与性能）。

## 小说转漫画模块
### 一、核心流程与逻辑设计
- 请详细描述小说转漫画的完整流程？需结合前后端交互逻辑说明：
前端：用户在漫画制作页输入基础信息（漫画名称、描述、是否公开、分镜数量、风格）和小说文本，点击 “提交小说” 后，将数据通过接口发送至后端。
后端：接收数据后，调用 LLM 模型（如通义千问 qwen-plus）对小说文本进行处理，按结构化提示词（包含场景编号、核心元素、动作描述、前后关联点等）分割为对应数量的分镜，返回分镜数据给前端。
前端展示分镜后，用户点击 “生成漫画”，前端将分镜信息发送至后端，后端调用 AIGC 服务生成漫画图片，返回图片标识。
前端通过标识查询图片，展示预览；后端将漫画信息（图片 URL、分镜数据等）存入 MySQL，支持后续下载、编辑等操作。
- 分镜生成的依据是什么？如何确保分镜符合漫画叙事逻辑？
分镜生成依据：基于 LLM 模型对小说文本的语义分析，提取关键情节、场景转折点、角色动作等核心信息，结合用户选择的分镜数量（2-6 个）进行拆分。
叙事逻辑保障：通过结构化提示词设计，强制每个分镜包含 “与前后场景的关联点” 和 “序列权重”，确保分镜按情节发展顺序衔接；同时支持用户手动调整分镜内容，补充创作意图。
### 二、技术实现与关键难点
- 如何解决 “文本到分镜的智能转换” 这一难点？具体用了哪些技术手段？
解决方案：采用 “LLM 模型 + 结构化提示词” 组合策略。
提示词设计：明确要求分镜包含场景类型、核心元素、动作描述、氛围渲染、前后关联点等字段，确保分镜信息结构化、可直接用于图像生成。
后处理优化：对 LLM 返回的分镜数据补充漫画专属提示词（如镜头类型：全景 / 近景 / 特写）和顺序权重，为后续图像生成和排版提供依据。
- 生成的漫画图像如何保证风格统一和角色形象一致性？
风格统一：前端允许用户指定漫画风格（如 “中式悬疑”“科幻未来”），后端在调用 AIGC 服务时，将风格信息嵌入提示词，强制所有分镜遵循同一风格指令。
角色一致性：通过提示词关联机制，要求后续分镜明确引用上一分镜的角色特征（如 “与分镜 1 中穿红裙的女孩形象保持一致”），避免角色脱节；同时统一角色命名和核心特征描述（如 “短发、戴眼镜的男生”）。

### 三、用户体验与交互设计
- 前端在漫画生成过程中做了哪些交互优化，提升用户体验？
状态反馈：提交小说和生成漫画时，按钮显示 “提交中...”“生成中...” 加载状态，避免重复操作；分镜和图片生成过程中展示加载动画，减少等待焦虑。
分镜交互：支持分镜 “全部展开 / 收起”“复制所有分镜” 功能，方便用户查看和调整；分镜卡片点击可切换展开状态，聚焦单镜细节。
表单验证：通过rules定义严格的输入规则（如漫画名称 1-50 字符、描述 1-200 字符），失焦时实时提示错误，减少无效提交。
- 用户对生成的分镜或漫画不满意时，有哪些操作入口？
分镜阶段：用户可直接修改分镜描述（如补充角色特征、调整动作），重新提交生成漫画。
漫画阶段：通过个人中心的 “编辑漫画” 功能，修改漫画名称、描述等信息；若需调整图像，可重新生成对应分镜的图片（未来规划中可扩展高级编辑工具）。
### 四、异常处理与性能优化
- LLM 或 AIGC 服务调用失败时，系统如何处理？
前端：通过try/catch捕获接口异常，展示友好提示（如 “分镜生成失败，请重试”），保留用户已输入的文本内容，避免重复填写。
后端：记录错误日志（如服务超时、返回格式异常），对临时失败的请求支持重试机制；若服务不可用，返回降级提示（如 “当前 AI 服务繁忙，请稍后再试”）。
- 大量用户同时生成漫画时，如何避免系统性能瓶颈？
前端：对生成请求添加防抖处理，避免短时间内重复调用接口；分镜和图片加载采用懒加载，优先渲染可视区域内容。
后端：AIGC 调用采用异步处理，通过任务队列管理生成请求，避免并发过高导致服务崩溃；对高频生成的风格或分镜类型，可缓存提示词模板，减少重复计算。
### 五、扩展性与未来规划
- 如果要添加 “分镜手动调整” 功能（如拖拽调整顺序），需要做哪些改动？
前端：在分镜展示模块引入拖拽组件（如vuedraggable），允许用户调整分镜顺序；同步更新分镜的 “序列权重” 和 “前后关联点” 字段。
后端：调整分镜数据存储结构，支持按用户调整后的顺序重新排序；生成漫画时按新顺序调用 AIGC 服务，确保图像序列与分镜顺序一致。
- 未来如何提升漫画生成的质量和效率？
质量优化：扩展风格模板库（如 “日系二次元”“美式漫画”），细化提示词参数（如线条风格、色彩饱和度）；引入用户反馈机制，对低评分生成结果分析并优化提示词。
效率提升：集成模型微调功能，基于平台历史数据训练专属模型；实现分镜并行生成（在保证风格一致的前提下），缩短整体生成时间。

## 聊天模版

###  核心功能与实现思路
- 问题：聊天广场的核心功能是什么？如何设计整体流程实现用户在线讨论？
思路：
核心功能是支持用户实时发送消息、查看历史消息、获取在线用户列表。
整体流程可参考项目设计：前端用户进入页面后，后端通过 “查询历史模块” 和 “在线用户模块” 从 MySQL 获取历史消息和在线用户数据并返回前端；用户发送消息时，后端通过 “消息接收 / 发送模块” 处理消息，存储到 MySQL，再通过 “广播模块” 将消息推送给所有在线用户，实现实时同步。
### 实时通讯技术选型
- 问题：聊天广场为什么选择 WebSocket 而非 HTTP 实现实时通讯？实现中如何保证消息的实时性？
思路：
选择原因：HTTP 是 “请求 - 响应” 模式，无法主动推送消息；WebSocket 是长连接，支持服务器主动向客户端推送消息，更适合实时聊天场景（项目中client/src/api/chat.js有 WebSocket 相关代码设计）。
实时性保证：通过 WebSocket 建立持久连接，消息发送后由后端 “广播模块” 即时推送给所有在线用户，避免轮询带来的延迟和资源浪费。
### 在线用户管理
- 问题：如何实时维护在线用户列表？用户断开连接时如何处理状态？
思路：
在线状态维护：用户登录聊天广场时，通过 WebSocket 连接携带身份标识（如 UUID），后端记录用户连接状态（可结合 Redis 存储在线用户 ID）；
断开处理：监听 WebSocket 的onclose事件，当用户断开连接时，后端移除该用户的在线状态，并广播更新在线用户列表到所有客户端。
### 消息存储与历史查询
- 问题：聊天记录如何存储？查询历史消息时如何优化性能？
思路：
存储设计：使用 MySQL 存储消息，表结构可包含消息ID、发送者ID、内容、发送时间、是否已读等字段（参考项目 “论坛模块” 与 MySQL 的交互设计）；
性能优化：查询历史消息时采用分页查询（限制单页加载数量），避免一次性加载大量数据；可针对时间字段建立索引，提升按时间范围查询的效率。
### 技术难点与解决方案
- 问题：实现聊天广场时遇到的最大技术难点是什么？如何解决？
思路：
可能的难点包括 “消息广播效率” 和 “网络异常处理”：
消息广播：当在线用户较多时，广播消息可能导致性能瓶颈。解决方案：采用 “房间 / 频道” 机制（如按聊天广场分组），仅向当前广场内的用户广播；结合消息队列（如 RabbitMQ）异步处理广播任务，避免阻塞主线程。
网络异常：用户断网后消息可能丢失。解决方案：实现重连机制，重连后自动同步断网期间的消息；后端暂存未送达的消息，待用户重新连接后推送。
### 安全性与用户体验
- 问题：如何防止聊天广场中的恶意消息（如 XSS 攻击）？如何优化用户体验（如消息状态提示）？
思路：
安全性：对用户输入的消息内容进行过滤（如转义 HTML 特殊字符），防止 XSS 攻击；验证用户身份（如通过 Token），禁止未登录用户发送消息。
用户体验：添加消息状态提示（“发送中”“已发送”“已读”）；滚动加载更多历史消息；新消息通知（如声音提示、未读数量标记）。
### 扩展性设计
- 问题：如果聊天广场用户量激增，如何保证系统的扩展性？
思路：
前端：通过虚拟滚动列表优化大量消息的渲染性能（参考项目 “漫画广场” 的虚拟滚动方案）。
后端：采用集群部署，通过负载均衡分发 WebSocket 连接；使用 Redis 的发布 / 订阅功能（Pub/Sub）实现多服务器间的消息同步，避免单节点瓶颈。

